const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const Sentiment = require('sentiment');
const puppeteer = require('puppeteer');
const { spawn } = require('child_process');

// Load environment variables with explicit path
require('dotenv').config({ path: path.join(__dirname, '.env') });

console.log('üîç Environment Debug:');
console.log('- NODE_ENV:', process.env.NODE_ENV);
console.log('- PORT:', process.env.PORT);
console.log('- GEMINI_API_KEY length:', process.env.GEMINI_API_KEY ? process.env.GEMINI_API_KEY.length : 'undefined');
console.log('- GEMINI_API_KEY starts with:', process.env.GEMINI_API_KEY ? process.env.GEMINI_API_KEY.substring(0, 10) + '...' : 'undefined');
console.log('- GOOGLE_SEARCH_API_KEY length:', process.env.GOOGLE_SEARCH_API_KEY ? process.env.GOOGLE_SEARCH_API_KEY.length : 'undefined');
console.log('- GOOGLE_SEARCH_ENGINE_ID length:', process.env.GOOGLE_SEARCH_ENGINE_ID ? process.env.GOOGLE_SEARCH_ENGINE_ID.length : 'undefined');
console.log('- .env file path:', path.join(__dirname, '.env'));
console.log('- .env file exists:', fs.existsSync(path.join(__dirname, '.env')));

const app = express();
const PORT = process.env.PORT || 5000;

// Gemini API Configuration
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

// API Key validation - Test modunda √ßalƒ±≈üacak
if (!GEMINI_API_KEY || GEMINI_API_KEY === 'your-gemini-api-key-here') {
  console.warn('‚ö†Ô∏è  UYARI: GEMINI_API_KEY tanƒ±mlanmamƒ±≈ü veya placeholder!');
  console.warn('üí° Ger√ßek bir API key edinmek i√ßin: https://makersuite.google.com/app/apikey');
  console.warn('üîÑ ≈ûu an test modunda √ßalƒ±≈üacak...');
} else {
  console.log('ü§ñ Gemini API Yapƒ±landƒ±rmasƒ±: ‚úÖ Tamam');
}

// Sentiment analyzer
const sentiment = new Sentiment();

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// File upload configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, 'uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${uuidv4()}-${file.originalname}`;
    cb(null, uniqueName);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Sadece g√∂rsel dosyalarƒ± kabul edilir'), false);
    }
  }
});

// Rate limiting i√ßin basit in-memory store
const requestCounts = new Map();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 dakika
const MAX_REQUESTS_PER_WINDOW = 20; // 1 dakikada maksimum 20 istek (artƒ±rƒ±ldƒ±)

// Rate limiting middleware
const rateLimit = (req, res, next) => {
  const clientIP = req.ip || req.connection.remoteAddress;
  const now = Date.now();

  // Eski kayƒ±tlarƒ± temizle
  if (requestCounts.has(clientIP)) {
    const { count, timestamp } = requestCounts.get(clientIP);
    if (now - timestamp > RATE_LIMIT_WINDOW) {
      requestCounts.delete(clientIP);
    }
  }

  // Mevcut istek sayƒ±sƒ±nƒ± kontrol et
  const current = requestCounts.get(clientIP) || { count: 0, timestamp: now };

  if (current.count >= MAX_REQUESTS_PER_WINDOW) {
    return res.status(429).json({
      error: 'Rate limit exceeded',
      message: '√áok fazla istek g√∂nderildi. L√ºtfen biraz bekleyip tekrar deneyin.',
      retryAfter: Math.ceil((RATE_LIMIT_WINDOW - (now - current.timestamp)) / 1000)
    });
  }

  // ƒ∞stek sayƒ±sƒ±nƒ± artƒ±r
  requestCounts.set(clientIP, {
    count: current.count + 1,
    timestamp: current.timestamp
  });

  next();
};

// AI Service Implementation with Real Google Search Integration
class AIService {
  constructor() {
    this.geminiApiKey = GEMINI_API_KEY;
    this.geminiApiUrl = GEMINI_API_URL;
    this.googleSearchApiKey = process.env.GOOGLE_SEARCH_API_KEY;
    this.googleSearchEngineId = process.env.GOOGLE_SEARCH_ENGINE_ID;
    this.productCache = new Map(); // Cache for products
  }

  // Query Agent - GitHub projesinden adaptasyon
  async extractProductFeatures(query) {
    try {
      console.log('üß† Query Agent √ßalƒ±≈üƒ±yor - sorgu analiz ediliyor...');

      const analysisPrompt = `
      Bu √ºr√ºn arama sorgusunu analiz et ve ≈üu bilgileri √ßƒ±kar:
      
      Sorgu: "${query}"
      
      √áƒ±karƒ±lacak bilgiler:
      1. √úr√ºn kategorisi (tablo, √ßer√ßeve, dekorasyon vs.)
      2. Renkler (mavi, kƒ±rmƒ±zƒ±, beyaz vs.)
      3. Boyut tercihi (k√º√ß√ºk, orta, b√ºy√ºk)
      4. Stil (modern, klasik, minimalist vs.)
      5. Fiyat aralƒ±ƒüƒ± (varsa)
      6. Anahtar kelimeler
      
      JSON formatƒ±nda d√∂nd√ºr.
      `;

      const response = await axios.post(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.geminiApiKey}`,
        {
          contents: [{
            parts: [{ text: analysisPrompt }]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 1000
          }
        },
        {
          headers: { 'Content-Type': 'application/json' }
        }
      );

      const analysisText = response.data.candidates[0]?.content?.parts[0]?.text || '';

      try {
        const features = JSON.parse(analysisText);
        return features;
      } catch (parseError) {
        // Fallback parsing
        return this.parseQueryManually(query);
      }
    } catch (error) {
      console.error('Query Agent hatasƒ±:', error);
      return this.parseQueryManually(query);
    }
  }

  // Manual query parsing fallback
  parseQueryManually(query) {
    const queryLower = query.toLowerCase();

    // Renk tespiti
    const colors = [];
    const colorMap = {
      'mavi': 'mavi', 'blue': 'mavi',
      'kƒ±rmƒ±zƒ±': 'kƒ±rmƒ±zƒ±', 'red': 'kƒ±rmƒ±zƒ±',
      'ye≈üil': 'ye≈üil', 'green': 'ye≈üil',
      'sarƒ±': 'sarƒ±', 'yellow': 'sarƒ±',
      'beyaz': 'beyaz', 'white': 'beyaz',
      'siyah': 'siyah', 'black': 'siyah',
      'gri': 'gri', 'gray': 'gri',
      'kahverengi': 'kahverengi', 'brown': 'kahverengi'
    };

    Object.keys(colorMap).forEach(key => {
      if (queryLower.includes(key)) {
        colors.push(colorMap[key]);
      }
    });

    // Boyut tespiti
    let size = 'orta';
    if (queryLower.includes('k√º√ß√ºk') || queryLower.includes('small')) size = 'k√º√ß√ºk';
    if (queryLower.includes('b√ºy√ºk') || queryLower.includes('large')) size = 'b√ºy√ºk';

    // Stil tespiti
    let style = 'modern';
    if (queryLower.includes('klasik') || queryLower.includes('classic')) style = 'klasik';
    if (queryLower.includes('minimalist')) style = 'minimalist';
    if (queryLower.includes('bohem') || queryLower.includes('bohemian')) style = 'bohem';

    return {
      category: 'tablo',
      colors: colors,
      size: size,
      style: style,
      keywords: query.split(' ').filter(word => word.length > 2)
    };
  }

  // GER√áEK Trendyol Scraping - Puppeteer ile
  async scrapeTrendyolProducts(query, features) {
    try {
      console.log('üï∑Ô∏è Trendyol scraping ba≈ülatƒ±lƒ±yor...');
      console.log('Arama sorgusu:', query);

      const browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--no-first-run',
          '--disable-extensions',
          '--disable-plugins',
          '--disable-background-timer-throttling',
          '--disable-backgrounding-occluded-windows',
          '--disable-renderer-backgrounding',
          '--disable-features=VizDisplayCompositor',
          '--disable-blink-features=AutomationControlled'
        ],
        timeout: 30000
      });

      const page = await browser.newPage();

      // Basit User-Agent
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');

      await page.setViewport({ width: 1280, height: 720 });

      // Bot tespitini √∂nle
      await page.evaluateOnNewDocument(() => {
        Object.defineProperty(navigator, 'webdriver', { get: () => false });
        Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
        Object.defineProperty(navigator, 'languages', { get: () => ['tr-TR', 'tr', 'en-US', 'en'] });
      });

      // Arama URL'si olu≈ütur
      const searchQuery = this.buildTrendyolSearchQuery(query, features);
      const trendyolUrl = `https://www.trendyol.com/sr?q=${encodeURIComponent(searchQuery)}`;

      console.log('üîç Trendyol URL:', trendyolUrl);

      // Sayfayƒ± y√ºkle
      await page.goto(trendyolUrl, {
        waitUntil: 'domcontentloaded',
        timeout: 30000
      });

      // √úr√ºn kartlarƒ±nƒ± bekle
      await page.waitForSelector('.p-card-wrppr, .product-down, .prdct-cntnr-wrppr', {
        timeout: 10000
      });

      // √úr√ºnleri √ßek
      const products = await page.evaluate(() => {
        const productCards = document.querySelectorAll('.p-card-wrppr, .product-down, .prdct-cntnr-wrppr');
        const results = [];

        productCards.forEach((card, index) => {
          try {
            // √úr√ºn linki
            const linkElement = card.querySelector('a');
            const link = linkElement ? linkElement.href : '';

            // √úr√ºn resmi
            const imgElement = card.querySelector('img');
            let image = '';
            if (imgElement) {
              image = imgElement.getAttribute('data-src') || imgElement.getAttribute('data-original') || imgElement.src || '';
            }

            // √úr√ºn adƒ± ve detay bilgileri
            const nameElement = card.querySelector('.prdct-desc-cntnr-name, .name, .product-title');
            const name = nameElement ? nameElement.textContent.trim() : '';

            // Marka bilgisini ayrƒ± √ßek
            const brandElement = card.querySelector('.prdct-desc-cntnr-name a, .brand-name, .product-brand');
            const brand = brandElement ? brandElement.textContent.trim() : '';

            // √úr√ºn a√ßƒ±klama metnini √ßek (eƒüer varsa)
            const descElement = card.querySelector('.prdct-desc-cntnr-ttl, .product-desc, .product-description');
            const description = descElement ? descElement.textContent.trim() : '';

            // √ñne √ßƒ±kan √∂zellikler (eƒüer varsa)
            const featuresElements = card.querySelectorAll('.prdct-features li, .product-features li, .highlighted-features li');
            const features = Array.from(featuresElements).map(el => el.textContent.trim()).filter(f => f.length > 0);

            // Fiyat bilgileri - Sadece discounted, yoksa new_price al
            let price = '';
            let originalPrice = null;

            // 1. √ñnce discounted fiyat ara
            const discountedElement = card.querySelector('.discounted, .prc-box-dscntd, [class*="discounted"]');

            if (discountedElement) {
              // ƒ∞ndirimli fiyat bulundu
              price = discountedElement.textContent.trim();

              // Orijinal fiyat da varsa al
              const originalElement = card.querySelector('.original, .prc-box-orgnl, [class*="original"]');
              if (originalElement) {
                originalPrice = originalElement.textContent.trim();
              }

              console.log(`üí∞ ƒ∞ndirimli √ºr√ºn bulundu - ƒ∞ndirimli: ${price}, Orijinal: ${originalPrice}`);
            } else {
              // 2. discounted yoksa new_price ara
              const newPriceElement = card.querySelector('.new_price, .prc-box-sllng, [class*="new_price"]');

              if (newPriceElement) {
                price = newPriceElement.textContent.trim();
                originalPrice = null;
                console.log(`üí∞ Normal fiyat bulundu - New Price: ${price}`);
              } else {
                // 3. Son √ßare: herhangi bir fiyat elementi
                const anyPriceElement = card.querySelector('[class*="price"], [class*="prc"], [class*="TL"]');
                price = anyPriceElement ? anyPriceElement.textContent.trim() : '';
                console.log(`üí∞ Fallback fiyat bulundu - Fiyat: ${price}`);
              }
            }

            // Rating
            const ratingElement = card.querySelector('.rating-score, .rating');
            const ratingText = ratingElement ? ratingElement.textContent.trim() : '';
            const rating = parseFloat(ratingText.match(/[\d,\.]+/)?.[0]?.replace(',', '.')) || (4.0 + Math.random());

            // Review count
            const reviewElement = card.querySelector('.rating-text, .comment-count');
            const reviewText = reviewElement ? reviewElement.textContent.trim() : '';
            const reviewCount = parseInt(reviewText.match(/\d+/)?.[0]) || Math.floor(Math.random() * 200) + 10;

            // Sadece ge√ßerli veriye sahip √ºr√ºnleri ekle
            if (name && price && image && link) {
              results.push({
                id: `trendyol_${index}_${Date.now()}`,
                name: name,
                price: price,
                originalPrice: originalPrice || null,
                rating: rating,
                reviewCount: reviewCount,
                image: image,
                link: link.startsWith('http') ? link : `https://www.trendyol.com${link}`,
                source: 'Trendyol',
                // Yeni alanlar
                extractedBrand: brand || null,
                extractedDescription: description || null,
                extractedFeatures: features || [],
                rawData: {
                  name: name,
                  price: price,
                  originalPrice: originalPrice,
                  rating: rating,
                  reviewCount: reviewCount,
                  brand: brand,
                  description: description,
                  features: features
                }
              });
            }
          } catch (error) {
            console.log(`Product ${index} parse error:`, error.message);
          }
        });

        return results;
      });

      await browser.close();

      if (products && products.length > 0) {
        console.log(`‚úÖ Trendyol'dan ${products.length} √ºr√ºn bulundu`);
        const processedProducts = products.map(product => this.processTrendyolProduct(product, features));
        return processedProducts.slice(0, 10);
      } else {
        throw new Error('Hi√ß √ºr√ºn bulunamadƒ±');
      }

    } catch (error) {
      console.error('‚ùå Trendyol scraping hatasƒ±:', error.message);
      console.log('‚ö†Ô∏è Fallback: Google Search kullanƒ±lacak...');
      return await this.fallbackToGoogleSearch(query, features);
    }
  }

  // Fallback: Google Search ile √ºr√ºn arama
  async fallbackToGoogleSearch(query, features) {
    try {
      console.log('üîÑ Google Search fallback ba≈ülatƒ±lƒ±yor...');

      // Google Search kullanarak √ºr√ºn ara
      const optimizedQuery = this.optimizeGoogleSearchQuery(query, features);
      const searchResults = await this.performGoogleSearch(optimizedQuery);

      if (searchResults && searchResults.length > 0) {
        const products = await this.convertSearchResultsToProducts(searchResults, features);
        console.log(`‚úÖ Google Search'ten ${products.length} √ºr√ºn bulundu`);
        return products;
      } else {
        throw new Error('Google Search\'te de √ºr√ºn bulunamadƒ±');
      }
    } catch (error) {
      console.error('‚ùå Google Search fallback hatasƒ±:', error);
      console.log('‚ö†Ô∏è Son √ßare: Sistem mesajƒ± g√∂steriliyor...');
      return this.getFallbackProducts();
    }
  }

  // Trendyol arama sorgusu olu≈ütur
  buildTrendyolSearchQuery(query, features) {
    let searchQuery = query;

    // Tablo/dekorasyon terimleri ekle
    const decorTerms = ['tablo', 'kanvas', 'duvar', 'dekorasyonu', 'sanat'];
    const hasDecorTerm = decorTerms.some(term => searchQuery.toLowerCase().includes(term));

    if (!hasDecorTerm) {
      searchQuery += ' tablo';
    }

    // Stil bilgisi ekle
    if (features.style && features.style !== 'modern') {
      searchQuery += ` ${features.style}`;
    }

    // Renk bilgisi ekle (sadece ilk renk)
    if (features.colors && features.colors.length > 0) {
      searchQuery += ` ${features.colors[0]}`;
    }

    console.log('üîç Olu≈üturulan Trendyol sorgusu:', searchQuery);
    return searchQuery;
  }

  // Trendyol √ºr√ºn√ºn√º i≈üle
  processTrendyolProduct(product, features) {
    try {
      // Marka bilgisini √∂nce √ßekilen veriden al, yoksa isimden √ßƒ±kar
      const brand = product.extractedBrand || this.extractBrandFromName(product.name);

      // Fiyat formatƒ±nƒ± d√ºzenle
      const formattedPrice = this.formatTrendyolPrice(product.price);
      const formattedOriginalPrice = product.originalPrice ? this.formatTrendyolPrice(product.originalPrice) : null;

      // ƒ∞ndirim hesapla
      const discount = this.calculateDiscount(formattedPrice, formattedOriginalPrice);

      // A√ßƒ±klama: √áekilen a√ßƒ±klamayƒ± kullan, yoksa √ºr√ºn adƒ±nƒ± kullan
      const description = product.extractedDescription || product.name || 'Trendyol √ºr√ºn√º';

      // Renkler √ßƒ±kar
      const colors = this.extractColorsFromName(product.name);

      // Boyut bilgisi √ßƒ±kar
      const sizes = this.extractSizesFromName(product.name);

      // √ñzellikler: √áekilen √∂zellikleri kullan, yoksa varsayƒ±lan √∂zellikler
      const productFeatures = product.extractedFeatures && product.extractedFeatures.length > 0
        ? product.extractedFeatures
        : this.generateFeatures(product.name);

      return {
        id: product.id,
        name: product.name,
        price: formattedPrice,
        originalPrice: formattedOriginalPrice,
        discount: discount,
        rating: Math.min(5, Math.max(3.5, product.rating)),
        reviewCount: product.reviewCount,
        image: product.image,
        link: product.link,
        source: 'Trendyol',
        brand: brand,
        seller: 'Trendyol Satƒ±cƒ±sƒ±',
        description: description,
        features: productFeatures,
        colors: colors.length > 0 ? colors : ['√áok Renkli'],
        sizes: sizes.length > 0 ? sizes : ['Standart Boyut'],
        shipping: 'Trendyol kargo bilgisi i√ßin √ºr√ºn sayfasƒ±nƒ± ziyaret edin',
        deliveryTime: '1-3 i≈ü g√ºn√º',
        reviews: this.generateMockReviews(),
        aiScore: 0, // Bu sonra AI ile hesaplanacak
        aiRecommendation: 'Trendyol\'dan ger√ßek √ºr√ºn'
      };

    } catch (error) {
      console.error('√úr√ºn i≈üleme hatasƒ±:', error);
      return product;
    }
  }

  // Yardƒ±mcƒ± metodlar
  extractBrandFromName(name) {
    const brands = ['DekorArt', 'Tablo', 'Canvas', 'Poster', 'Frame', 'Art'];
    const nameWords = name.split(' ');

    for (const word of nameWords) {
      if (word.length > 2 && /^[A-Z]/.test(word)) {
        return word;
      }
    }

    return brands[Math.floor(Math.random() * brands.length)];
  }

  formatTrendyolPrice(priceText) {
    if (!priceText) return '0 TL';

    // Fiyat metni temizle - sadece rakam, virg√ºl ve nokta bƒ±rak
    let cleanPrice = priceText.replace(/[^\d,\.]/g, '');

    if (cleanPrice) {
      // T√ºrk Lirasƒ± formatƒ±nƒ± doƒüru anlayalƒ±m:
      // 1.050,75 TL = bin elli lira yetmi≈ü be≈ü kuru≈ü
      // 1.050 TL = bin elli lira
      // 50,75 TL = elli lira yetmi≈ü be≈ü kuru≈ü

      let priceValue;

      // Hem nokta hem virg√ºl varsa: 1.050,75 formatƒ±
      if (cleanPrice.includes('.') && cleanPrice.includes(',')) {
        // Noktalarƒ± kaldƒ±r (binlik ayra√ß), virg√ºl√º noktaya √ßevir (ondalƒ±k)
        cleanPrice = cleanPrice.replace(/\./g, '').replace(',', '.');
        priceValue = parseFloat(cleanPrice);
      }
      // Sadece nokta varsa: 1.050 formatƒ± (binlik ayra√ß)
      else if (cleanPrice.includes('.') && !cleanPrice.includes(',')) {
        // Eƒüer nokta son 3 haneden √∂nceyse binlik ayra√ßtƒ±r
        const dotIndex = cleanPrice.lastIndexOf('.');
        const afterDot = cleanPrice.substring(dotIndex + 1);

        if (afterDot.length === 3) {
          // Binlik ayra√ß: 1.050 ‚Üí 1050
          cleanPrice = cleanPrice.replace(/\./g, '');
          priceValue = parseFloat(cleanPrice);
        } else {
          // Ondalƒ±k: 10.50 ‚Üí 10.50
          priceValue = parseFloat(cleanPrice);
        }
      }
      // Sadece virg√ºl varsa: 50,75 formatƒ± (ondalƒ±k)
      else if (cleanPrice.includes(',') && !cleanPrice.includes('.')) {
        cleanPrice = cleanPrice.replace(',', '.');
        priceValue = parseFloat(cleanPrice);
      }
      // Hi√ß i≈üaret yoksa: 1050 formatƒ±
      else {
        priceValue = parseFloat(cleanPrice);
      }

      if (!isNaN(priceValue)) {
        // T√ºrk formatƒ±nda geri d√∂nd√ºr: 1050.75 ‚Üí 1.050,75 TL
        return priceValue.toLocaleString('tr-TR', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }) + ' TL';
      }
    }

    return '0,00 TL';
  }

  calculateDiscount(currentPrice, originalPrice) {
    if (!originalPrice || !currentPrice) return null;

    // Fiyat metinlerini sayƒ±sal deƒüerlere √ßevir
    const current = parseFloat(currentPrice.replace(/[^\d,\.]/g, '').replace(',', '.'));
    const original = parseFloat(originalPrice.replace(/[^\d,\.]/g, '').replace(',', '.'));

    // Hem deƒüerler ge√ßerli olmalƒ± hem de orijinal fiyat y√ºksek olmalƒ±
    if (!isNaN(current) && !isNaN(original) && original > current) {
      const discountPercent = Math.round(((original - current) / original) * 100);
      return `%${discountPercent}`;
    }

    return null;
  }

  generateProductDescription(name, features) {
    const templates = [
      'Modern ya≈üam alanlarƒ± i√ßin tasarlanmƒ±≈ü kaliteli duvar dekorasyonu',
      'Evinizi g√ºzelle≈ütiren ≈üƒ±k ve zarif tablo',
      'Y√ºksek kaliteli baskƒ± ile √ºretilen dekoratif sanat eseri',
      'Duvarlarƒ±nƒ±za renk katacak modern tasarƒ±m',
      'Minimalist ve ≈üƒ±k dekorasyon severlere √∂zel'
    ];

    return templates[Math.floor(Math.random() * templates.length)];
  }

  extractColorsFromName(name) {
    const colorMap = {
      'mavi': 'Mavi', 'blue': 'Mavi',
      'kƒ±rmƒ±zƒ±': 'Kƒ±rmƒ±zƒ±', 'red': 'Kƒ±rmƒ±zƒ±',
      'ye≈üil': 'Ye≈üil', 'green': 'Ye≈üil',
      'sarƒ±': 'Sarƒ±', 'yellow': 'Sarƒ±',
      'beyaz': 'Beyaz', 'white': 'Beyaz',
      'siyah': 'Siyah', 'black': 'Siyah',
      'gri': 'Gri', 'gray': 'Gri',
      'kahverengi': 'Kahverengi', 'brown': 'Kahverengi',
      'pembe': 'Pembe', 'pink': 'Pembe',
      'mor': 'Mor', 'purple': 'Mor'
    };

    const colors = [];
    const nameLower = name.toLowerCase();

    Object.keys(colorMap).forEach(key => {
      if (nameLower.includes(key)) {
        colors.push(colorMap[key]);
      }
    });

    return [...new Set(colors)]; // Duplikatlarƒ± kaldƒ±r
  }

  extractSizesFromName(name) {
    const sizePattern = /(\d+)\s*[xX√ó]\s*(\d+)\s*(cm|CM)?/g;
    const sizes = [];
    let match;

    while ((match = sizePattern.exec(name)) !== null) {
      sizes.push(`${match[1]}x${match[2]} cm`);
    }

    if (sizes.length === 0) {
      // Genel boyut terimleri
      if (name.toLowerCase().includes('b√ºy√ºk')) {
        sizes.push('70x100 cm');
      } else if (name.toLowerCase().includes('k√º√ß√ºk')) {
        sizes.push('30x40 cm');
      } else {
        sizes.push('50x70 cm');
      }
    }

    return sizes;
  }

  generateFeatures(name) {
    const baseFeatures = ['Kaliteli baskƒ±', 'Kolay asƒ±m'];

    if (name.toLowerCase().includes('kanvas')) {
      baseFeatures.push('Canvas baskƒ±');
    }

    if (name.toLowerCase().includes('√ßer√ßev')) {
      baseFeatures.push('√áer√ßeveli');
    }

    if (name.toLowerCase().includes('uv')) {
      baseFeatures.push('UV dayanƒ±mlƒ±');
    }

    baseFeatures.push('Duvar dekorasyonu');

    return baseFeatures;
  }

  // Google Custom Search API √ßaƒürƒ±sƒ±
  async performGoogleSearch(searchQuery) {
    try {
      if (!this.googleSearchApiKey || !this.googleSearchEngineId) {
        throw new Error('Google Search API anahtarlarƒ± eksik');
      }

      const searchUrl = 'https://www.googleapis.com/customsearch/v1';
      const params = {
        key: this.googleSearchApiKey,
        cx: this.googleSearchEngineId,
        q: searchQuery,
        searchType: 'image',
        num: 10, // Maksimum 10 sonu√ß
        imgType: 'photo',
        imgSize: 'medium',
        safe: 'active',
        rights: 'cc_publicdomain|cc_attribute|cc_sharealike|cc_noncommercial|cc_nonderived'
      };

      console.log('üåê Google Custom Search API √ßaƒürƒ±sƒ± yapƒ±lƒ±yor...');
      console.log('URL:', searchUrl);
      console.log('Parametreler:', params);

      const response = await axios.get(searchUrl, { params });

      if (response.data && response.data.items) {
        console.log(`‚úÖ Google'dan ${response.data.items.length} sonu√ß alƒ±ndƒ±`);
        return response.data.items;
      } else {
        throw new Error('Google API yanƒ±tƒ± ge√ßersiz');
      }

    } catch (error) {
      console.error('Google Search API hatasƒ±:', error);
      throw error;
    }
  }

  // Google arama sorgusunu optimize et
  optimizeGoogleSearchQuery(query, features) {
    let optimizedQuery = query;

    // E-ticaret sitelerini dahil et
    const ecommerceSites = [
      'site:trendyol.com',
      'site:hepsiburada.com',
      'site:n11.com',
      'site:amazon.com.tr',
      'site:gittigidiyor.com'
    ];

    // Oda stiline g√∂re ek anahtar kelimeler
    if (features.style) {
      const styleKeywords = this.getStyleKeywords(features.style);
      optimizedQuery += ` ${styleKeywords}`;
    }

    // Renk bilgisi ekle
    if (features.colors && features.colors.length > 0) {
      optimizedQuery += ` ${features.colors.join(' ')}`;
    }

    // √úr√ºn kategorisi ekle
    optimizedQuery += ' tablo duvar dekorasyonu canvas';

    // E-ticaret sitelerini ekle
    optimizedQuery += ` (${ecommerceSites.join(' OR ')})`;

    console.log('üîç Optimize edilmi≈ü Google sorgusu:', optimizedQuery);
    return optimizedQuery;
  }

  // Google arama sonu√ßlarƒ±nƒ± √ºr√ºn formatƒ±na √ßevir
  async convertSearchResultsToProducts(searchResults, features) {
    try {
      const products = [];

      for (let i = 0; i < searchResults.length; i++) {
        const result = searchResults[i];

        // URL'den site bilgisini √ßƒ±kar
        const source = this.extractSourceFromUrl(result.link);

        // Fiyat bilgisini URL'den √ßƒ±karmaya √ßalƒ±≈ü
        const priceInfo = this.extractPriceFromUrl(result.link);

        // AI ile √ºr√ºn analizi yap
        const aiAnalysis = await this.analyzeProductFromImage(result.link, features);

        const product = {
          id: `google_${i}_${Date.now()}`,
          name: this.extractProductName(result.title, result.snippet),
          price: priceInfo.price || this.generateRandomPrice(features),
          originalPrice: priceInfo.originalPrice || null,
          discount: priceInfo.discount || null,
          rating: aiAnalysis.rating || this.generateRandomRating(),
          reviewCount: aiAnalysis.reviewCount || this.generateRandomReviewCount(),
          image: result.link,
          link: result.image.contextLink || result.link,
          source: source,
          brand: aiAnalysis.brand || this.extractBrandFromTitle(result.title),
          seller: source,
          description: result.snippet || aiAnalysis.description || 'Modern duvar dekorasyonu',
          features: aiAnalysis.features || this.generateDefaultFeatures(features),
          colors: aiAnalysis.colors || features.colors || ['√áok Renkli'],
          sizes: aiAnalysis.sizes || ['Standart Boyut'],
          shipping: 'Kargo bilgisi i√ßin siteyi ziyaret edin',
          deliveryTime: '1-3 i≈ü g√ºn√º',
          reviews: aiAnalysis.reviews || this.generateMockReviews(),
          aiScore: aiAnalysis.aiScore || this.calculateBasicScore({ name: result.title, description: result.snippet }, query),
          aiRecommendation: aiAnalysis.recommendation || 'Google\'dan bulunan √ºr√ºn'
        };

        products.push(product);
      }

      return products;

    } catch (error) {
      console.error('√úr√ºn d√∂n√º≈üt√ºrme hatasƒ±:', error);
      return this.getFallbackProducts();
    }
  }

  // URL'den site bilgisini √ßƒ±kar
  extractSourceFromUrl(url) {
    try {
      const urlObj = new URL(url);
      const hostname = urlObj.hostname.toLowerCase();

      if (hostname.includes('trendyol')) return 'Trendyol';
      if (hostname.includes('hepsiburada')) return 'Hepsiburada';
      if (hostname.includes('n11')) return 'N11';
      if (hostname.includes('amazon')) return 'Amazon';
      if (hostname.includes('gittigidiyor')) return 'GittiGidiyor';

      return 'Google Arama';
    } catch (error) {
      return 'Google Arama';
    }
  }

  // URL'den fiyat bilgisini √ßƒ±karmaya √ßalƒ±≈ü
  extractPriceFromUrl(url) {
    try {
      // URL'de fiyat pattern'lerini ara
      const pricePatterns = [
        /(\d+)[.,](\d{2})/g,  // 299.99, 299,99
        /(\d+)\s*tl/gi,       // 299 TL
        /(\d+)\s*‚Ç∫/gi         // 299 ‚Ç∫
      ];

      for (const pattern of pricePatterns) {
        const matches = url.match(pattern);
        if (matches) {
          const price = matches[0].replace(/[^\d]/g, '');
          return {
            price: `${price.slice(0, -2)}.${price.slice(-2)}`,
            originalPrice: null,
            discount: null
          };
        }
      }

      return { price: null, originalPrice: null, discount: null };
    } catch (error) {
      return { price: null, originalPrice: null, discount: null };
    }
  }

  // Ba≈ülƒ±k ve snippet'ten √ºr√ºn adƒ±nƒ± √ßƒ±kar
  extractProductName(title, snippet) {
    try {
      // Ba≈ülƒ±ktan gereksiz kelimeleri temizle
      let name = title.replace(/[-|]/, ' ').trim();

      // √áok uzunsa kƒ±salt
      if (name.length > 60) {
        name = name.substring(0, 60) + '...';
      }

      return name || 'Duvar Dekorasyonu';
    } catch (error) {
      return 'Duvar Dekorasyonu';
    }
  }

  // Ba≈ülƒ±ktan marka bilgisini √ßƒ±kar
  extractBrandFromTitle(title) {
    try {
      const brandPatterns = [
        /([A-Z][a-z]+)\s+[A-Z]/g,
        /([A-Z]{2,})/g
      ];

      for (const pattern of brandPatterns) {
        const matches = title.match(pattern);
        if (matches && matches[0].length > 2) {
          return matches[0];
        }
      }

      return 'ArtDecor';
    } catch (error) {
      return 'ArtDecor';
    }
  }

  // AI ile g√∂rsel analiz yap
  async analyzeProductFromImage(imageUrl, features) {
    try {
      if (!this.geminiApiKey) {
        return this.getDefaultAnalysis();
      }

      const analysisPrompt = `
      Bu √ºr√ºn g√∂rselini analiz et ve ≈üu bilgileri JSON formatƒ±nda d√∂nd√ºr:
      
      {
        "rating": 4.0-5.0 arasƒ± puan,
        "reviewCount": 50-500 arasƒ± sayƒ±,
        "brand": "Marka adƒ±",
        "description": "√úr√ºn a√ßƒ±klamasƒ±",
        "features": ["√ñzellik1", "√ñzellik2"],
        "colors": ["Renk1", "Renk2"],
        "sizes": ["Boyut1", "Boyut2"],
        "reviews": [{"text": "Yorum", "rating": 5}],
        "aiScore": 70-95 arasƒ± puan,
        "recommendation": "AI √∂nerisi"
      }
      
      Oda stili: ${features.style || 'Modern'}
      Oda renkleri: ${features.colors ? features.colors.join(', ') : 'Belirtilmemi≈ü'}
      `;

      const response = await axios.post(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.geminiApiKey}`,
        {
          contents: [{
            parts: [
              { text: analysisPrompt },
              {
                inline_data: {
                  mime_type: "image/jpeg",
                  data: await this.getImageAsBase64(imageUrl)
                }
              }
            ]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 1000
          }
        }
      );

      const analysisText = response.data.candidates[0]?.content?.parts[0]?.text || '';

      try {
        return JSON.parse(analysisText);
      } catch (parseError) {
        console.log('AI analiz parse hatasƒ±, varsayƒ±lan deƒüerler kullanƒ±lacak');
        return this.getDefaultAnalysis();
      }

    } catch (error) {
      console.error('AI g√∂rsel analiz hatasƒ±:', error);
      return this.getDefaultAnalysis();
    }
  }

  // G√∂rseli base64'e √ßevir
  async getImageAsBase64(imageUrl) {
    try {
      const response = await axios.get(imageUrl, { responseType: 'arraybuffer' });
      return Buffer.from(response.data).toString('base64');
    } catch (error) {
      console.error('G√∂rsel base64 d√∂n√º≈üt√ºrme hatasƒ±:', error);
      return '';
    }
  }

  // Varsayƒ±lan analiz sonucu
  getDefaultAnalysis() {
    return {
      rating: 4.5,
      reviewCount: 120,
      brand: 'ArtDecor',
      description: 'Modern duvar dekorasyonu',
      features: ['Premium kalite', 'Kolay montaj'],
      colors: ['√áok Renkli'],
      sizes: ['Standart Boyut'],
      reviews: [
        { text: 'G√ºzel bir √ºr√ºn, tavsiye ederim', rating: 5 },
        { text: 'Kalitesi iyi, fiyatƒ± uygun', rating: 4 }
      ],
      aiScore: 80,
      recommendation: 'Google\'dan bulunan kaliteli √ºr√ºn'
    };
  }

  // Rastgele fiyat √ºret
  generateRandomPrice(features) {
    const basePrice = 150;
    const variation = Math.random() * 300;
    const finalPrice = basePrice + variation;
    return finalPrice.toFixed(2);
  }

  // Rastgele rating √ºret
  generateRandomRating() {
    return 4.0 + Math.random() * 1.0; // 4.0 - 5.0 arasƒ±
  }

  // Rastgele review count √ºret
  generateRandomReviewCount() {
    return Math.floor(50 + Math.random() * 450); // 50 - 500 arasƒ±
  }

  // Varsayƒ±lan √∂zellikler √ºret
  generateDefaultFeatures(features) {
    const baseFeatures = ['Premium kalite', 'Kolay montaj', 'Dayanƒ±klƒ± malzeme'];

    if (features.style === 'modern') {
      baseFeatures.push('Modern tasarƒ±m', 'Sade √ßizgiler');
    } else if (features.style === 'klasik') {
      baseFeatures.push('Klasik tarz', 'Zarif detaylar');
    }

    return baseFeatures;
  }

  // Mock yorumlar √ºret
  generateMockReviews() {
    const reviews = [
      { text: '√áok g√ºzel bir √ºr√ºn, tavsiye ederim', rating: 5 },
      { text: 'Kalitesi iyi, fiyatƒ± uygun', rating: 4 },
      { text: 'Hƒ±zlƒ± kargo, g√ºvenli paketleme', rating: 5 },
      { text: 'Beklentilerimi kar≈üƒ±ladƒ±', rating: 4 }
    ];

    return reviews.slice(0, Math.floor(Math.random() * 3) + 2); // 2-4 yorum
  }

  // Product Analysis Agent - GitHub projesinden esinlenerek
  async analyzeProductsWithAI(products, originalQuery, roomStyle, roomColors) {
    try {
      console.log('ü§ñ Product Analysis Agent √ßalƒ±≈üƒ±yor...');

      // Her √ºr√ºn i√ßin detaylƒ± analiz
      const analyzedProducts = await Promise.all(
        products.map(async (product) => {
          const analysis = await this.analyzeProduct(product, originalQuery, roomStyle, roomColors);
          return {
            ...product,
            ...analysis
          };
        })
      );

      // AI skoruna g√∂re sƒ±rala
      analyzedProducts.sort((a, b) => b.aiScore - a.aiScore);

      return analyzedProducts;
    } catch (error) {
      console.error('Product Analysis hatasƒ±:', error);
      // Fallback analysis
      return products.map(product => ({
        ...product,
        aiScore: this.calculateBasicScore(product, originalQuery),
        aiRecommendation: 'Temel analiz uygulandƒ±',
        sentimentScore: this.analyzeSentiment(product.reviews || [])
      }));
    }
  }

  // Individual product analysis
  async analyzeProduct(product, query, roomStyle, roomColors) {
    try {
      // Sentiment analysis for reviews
      const sentimentScore = this.analyzeSentiment(product.reviews || []);

      // AI-based compatibility analysis
      const compatibilityScore = await this.analyzeCompatibility(product, roomStyle, roomColors);

      // Calculate overall AI score
      const aiScore = this.calculateAdvancedScore(product, query, compatibilityScore, sentimentScore);

      // Generate AI recommendation
      const aiRecommendation = this.generateDetailedRecommendation(product, roomStyle, roomColors, sentimentScore);

      return {
        aiScore,
        aiRecommendation,
        sentimentScore,
        compatibilityScore
      };
    } catch (error) {
      console.error('√úr√ºn analiz hatasƒ±:', error);
      return {
        aiScore: this.calculateBasicScore(product, query),
        aiRecommendation: 'Analiz tamamlanamadƒ±',
        sentimentScore: 0.5,
        compatibilityScore: 0.5
      };
    }
  }

  // Sentiment Analysis Agent - GitHub projesinden
  analyzeSentiment(reviews) {
    if (!reviews || reviews.length === 0) return 0.5;

    let totalSentiment = 0;
    let validReviews = 0;

    reviews.forEach(review => {
      if (review.text) {
        const result = sentiment.analyze(review.text);
        // Normalize score to 0-1 range
        const normalizedScore = (result.score + 5) / 10; // Assuming score range is -5 to +5
        totalSentiment += Math.max(0, Math.min(1, normalizedScore));
        validReviews++;
      }
    });

    return validReviews > 0 ? totalSentiment / validReviews : 0.5;
  }

  // AI Compatibility Analysis
  async analyzeCompatibility(product, roomStyle, roomColors) {
    try {
      const compatibilityPrompt = `
      Bu √ºr√ºn√ºn oda stiliyle uyumluluƒüunu analiz et:
      
      √úr√ºn: ${product.name}
      A√ßƒ±klama: ${product.description}
      Renkler: ${product.colors.join(', ')}
      
      Oda Stili: ${roomStyle || 'Belirtilmemi≈ü'}
      Oda Renkleri: ${roomColors ? roomColors.join(', ') : 'Belirtilmemi≈ü'}
      
      0-1 arasƒ±nda uyumluluk skoru d√∂nd√ºr (sadece sayƒ±).
      `;

      const response = await axios.post(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.geminiApiKey}`,
        {
          contents: [{
            parts: [{ text: compatibilityPrompt }]
          }],
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 100
          }
        },
        {
          headers: { 'Content-Type': 'application/json' }
        }
      );

      const scoreText = response.data.candidates[0]?.content?.parts[0]?.text || '0.5';
      const score = parseFloat(scoreText.match(/\d+\.?\d*/)?.[0] || '0.5');

      return Math.max(0, Math.min(1, score));
    } catch (error) {
      console.error('Uyumluluk analizi hatasƒ±:', error);
      return 0.5;
    }
  }

  // Advanced scoring algorithm
  calculateAdvancedScore(product, query, compatibilityScore, sentimentScore) {
    let score = 0;

    // Query relevance (30%)
    const queryWords = query.toLowerCase().split(' ');
    const productText = (product.name + ' ' + product.description).toLowerCase();
    let queryMatch = 0;
    queryWords.forEach(word => {
      if (productText.includes(word)) queryMatch++;
    });
    score += (queryMatch / queryWords.length) * 30;

    // Rating score (20%)
    score += (product.rating / 5) * 20;

    // Review count impact (10%)
    score += Math.min(product.reviewCount / 100, 1) * 10;

    // Discount bonus (10%)
    if (product.discount) {
      score += (product.discount / 100) * 10;
    }

    // AI compatibility (20%)
    score += compatibilityScore * 20;

    // Sentiment score (10%)
    score += sentimentScore * 10;

    return Math.round(score);
  }

  // Basic scoring fallback
  calculateBasicScore(product, query) {
    let score = 0;

    const queryWords = query.toLowerCase().split(' ');
    const productText = (product.name + ' ' + product.description).toLowerCase();

    queryWords.forEach(word => {
      if (productText.includes(word)) score += 10;
    });

    score += product.rating * 5;
    score += Math.min(product.reviewCount / 10, 20);

    if (product.discount) score += 15;

    return Math.round(score);
  }

  // Detailed recommendation generation
  generateDetailedRecommendation(product, roomStyle, roomColors, sentimentScore) {
    const recommendations = [];

    // Style compatibility
    if (roomStyle) {
      const styleMatch = product.name.toLowerCase().includes(roomStyle.toLowerCase()) ||
        product.description.toLowerCase().includes(roomStyle.toLowerCase());
      if (styleMatch) {
        recommendations.push(`${roomStyle} tarzƒ±yla m√ºkemmel uyum`);
      }
    }

    // Color compatibility
    if (roomColors && roomColors.length > 0) {
      const matchingColors = product.colors.filter(productColor =>
        roomColors.some(roomColor =>
          productColor.toLowerCase().includes(roomColor.toLowerCase())
        )
      );
      if (matchingColors.length > 0) {
        recommendations.push(`${matchingColors.join(', ')} renkleri oda ile uyumlu`);
      }
    }

    // Quality indicators
    if (product.rating >= 4.5) {
      recommendations.push('Y√ºksek m√º≈üteri memnuniyeti');
    }

    if (sentimentScore > 0.7) {
      recommendations.push('Olumlu m√º≈üteri yorumlarƒ±');
    }

    if (product.discount && product.discount > 20) {
      recommendations.push('B√ºy√ºk indirim fƒ±rsatƒ±');
    }

    if (product.shipping === '√úcretsiz Kargo') {
      recommendations.push('√úcretsiz kargo avantajƒ±');
    }

    return recommendations.length > 0 ? recommendations.join(' ‚Ä¢ ') : 'Genel kullanƒ±ma uygun';
  }

  // Main search function - Ger√ßek Trendyol Scraping
  async searchProducts(query, roomStyle, roomColors) {
    console.log('üîç AI √úr√ºn Arama Agent √ßalƒ±≈üƒ±yor...');
    console.log('Sorgu:', query);
    console.log('Oda Stili:', roomStyle);
    console.log('Oda Renkleri:', roomColors);

    try {
      // 1. Query Agent - Sorguyu analiz et
      let features;
      try {
        features = await this.extractProductFeatures(query);
        console.log('‚úÖ √áƒ±karƒ±lan √∂zellikler:', features);
      } catch (error) {
        console.log('‚ö†Ô∏è Query analizi ba≈üarƒ±sƒ±z, manuel parsing kullanƒ±lƒ±yor...');
        features = this.parseQueryManually(query);
      }

      // 2. Ger√ßek Trendyol Scraping
      console.log('üï∑Ô∏è Trendyol\'dan ger√ßek √ºr√ºn √ßekiliyor...');
      const products = await this.scrapeTrendyolProducts(query, features);

      if (products.length === 0) {
        throw new Error('Hi√ß √ºr√ºn bulunamadƒ±');
      }

      console.log(`‚úÖ ${products.length} ger√ßek √ºr√ºn bulundu`);

      // 3. Product Analysis - √úr√ºnleri AI ile analiz et (isteƒüe baƒülƒ±)
      let analyzedProducts;
      try {
        analyzedProducts = await this.analyzeProductsWithAI(products, query, roomStyle, roomColors);
        console.log(`ü§ñ AI analizi ba≈üarƒ±lƒ±: ${analyzedProducts.length} √ºr√ºn analiz edildi`);
      } catch (aiError) {
        console.error('‚ö†Ô∏è AI analizi ba≈üarƒ±sƒ±z, temel skorlama kullanƒ±lacak:', aiError.message);
        // AI ba≈üarƒ±sƒ±z olursa temel skorlama kullan
        analyzedProducts = products.map(product => ({
          ...product,
          aiScore: this.calculateBasicScore(product, query),
          aiRecommendation: 'Temel analiz uygulandƒ±',
          sentimentScore: 0.7
        }));
      }

      console.log(`üì¶ Toplam ${analyzedProducts.length} √ºr√ºn hazƒ±rlandƒ±`);
      return analyzedProducts.slice(0, 10); // En iyi 10 √ºr√ºn√º d√∂nd√ºr

    } catch (error) {
      console.error('‚ùå √úr√ºn arama ba≈üarƒ±sƒ±z:', error);

      // Fallback olarak Google Search kullan
      try {
        console.log('üîÑ Google Search fallback √ßalƒ±≈üƒ±yor...');
        return await this.fallbackToGoogleSearch(query, features || this.parseQueryManually(query));
      } catch (fallbackError) {
        console.error('‚ùå Google Search fallback da ba≈üarƒ±sƒ±z:', fallbackError);
        console.log('‚ö†Ô∏è Son √ßare: Sistem mesajƒ± g√∂steriliyor...');
        return this.getFallbackProducts();
      }
    }
  }

  // Agent 2: Oda G√∂rsel Analiz Ajanƒ± - GER√áEK AI
  async analyzeRoom(imageBase64) {
    console.log('üëÅÔ∏è AI Oda Analiz Agent √ßalƒ±≈üƒ±yor...');

    // Gemini ile ger√ßek g√∂rsel analiz
    const analysis = await this.performVisionAnalysis(imageBase64);

    return analysis;
  }

  async analyzeRoomWithProduct(roomImageBase64, product) {
    console.log('üéØ AI √úr√ºne √ñzel Yerle≈ütirme Analiz Agent √ßalƒ±≈üƒ±yor...', product.name);

    // Gemini ile √ºr√ºne √∂zel yerle≈ütirme analizi
    const analysis = await this.performProductSpecificAnalysis(roomImageBase64, product);

    return analysis;
  }

  // Agent 3: Yerle≈ütirme Ajanƒ± - GER√áEK AI
  async placeProductInRoom(roomImageBase64, productImageBase64, placementData) {
    console.log('üé® AI Yerle≈ütirme Agent √ßalƒ±≈üƒ±yor...');

    // Gemini ile ger√ßek g√∂rsel √ºretim
    const result = await this.performPlacement(roomImageBase64, productImageBase64, placementData);

    return result;
  }

  // Hugging Face Background Removal API - √úCRETSƒ∞Z!
  async removeBackground(imageBase64) {
    try {
      console.log('üñºÔ∏è BRIA-RMBG-2.0 ile arka plan kaldƒ±rƒ±lƒ±yor...');

      // Base64'ten buffer'a √ßevir
      const imageBuffer = Buffer.from(imageBase64.split(',')[1], 'base64');

      // BRIA-RMBG-2.0 modeli - En g√ºncel ve g√ºvenilir model
      const response = await axios.post(
        'https://api-inference.huggingface.co/models/briaai/BRIA-RMBG-2.0',
        imageBuffer,
        {
          headers: {
            'Content-Type': 'application/octet-stream',
          },
          responseType: 'arraybuffer',
          timeout: 30000 // 30 saniye timeout
        }
      );

      // Sonucu base64'e √ßevir
      const processedBuffer = Buffer.from(response.data);
      const processedBase64 = `data:image/png;base64,${processedBuffer.toString('base64')}`;

      console.log('‚úÖ Arka plan ba≈üarƒ±yla kaldƒ±rƒ±ldƒ±!');
      return processedBase64;

    } catch (error) {
      console.error('‚ùå Background removal hatasƒ±:', error);
      console.error('Hata detaylarƒ±:', {
        message: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText
      });

      // Hata durumunda orijinal g√∂rseli d√∂nd√ºr
      console.log('‚ö†Ô∏è Fallback: Orijinal g√∂rsel kullanƒ±lacak');
      return imageBase64;
    }
  }

  // Helper methods
  async optimizeSearchQuery(query, roomStyle, roomColors) {
    // AI ile query optimize et
    let optimizedQuery = query;

    if (roomStyle) {
      const styleKeywords = this.getStyleKeywords(roomStyle);
      optimizedQuery += ` ${styleKeywords}`;
    }

    if (roomColors && roomColors.length > 0) {
      optimizedQuery += ` ${roomColors[0]} tonlarda`;
    }

    optimizedQuery += ' tablo duvar dekorasyonu canvas';

    console.log('Optimize edilmi≈ü sorgu:', optimizedQuery);
    return optimizedQuery;
  }

  getStyleKeywords(style) {
    const styleMap = {
      'Modern Minimalist': 'modern minimalist sade',
      'Klasik': 'klasik antika vintage',
      'Bohem': 'bohem renkli etnik',
      'End√ºstriyel': 'end√ºstriyel metal siyah',
      'Scandinavian': 'nordic beyaz doƒüa'
    };
    return styleMap[style] || 'modern';
  }

  // Basit Fallback (sadece scraping tamamen ba≈üarƒ±sƒ±z olursa)
  getFallbackProducts() {
    return [
      {
        id: 'fallback_001',
        name: '√úr√ºn Bulunamadƒ± - L√ºtfen Farklƒ± Arama Deneyin',
        price: '0 TL',
        rating: 0,
        reviewCount: 0,
        image: 'https://via.placeholder.com/400x300/f3f4f6/6b7280?text=√úr√ºn+Bulunamadƒ±',
        link: 'https://www.trendyol.com',
        source: 'Sistem',
        brand: 'Sistem',
        seller: 'Sistem',
        description: 'Trendyol scraping sistemi ge√ßici olarak √ßalƒ±≈ümƒ±yor. L√ºtfen farklƒ± arama terimleri deneyin.',
        features: ['Sistem mesajƒ±'],
        colors: ['Gri'],
        sizes: ['N/A'],
        shipping: 'N/A',
        deliveryTime: 'N/A',
        aiScore: 0,
        aiRecommendation: 'L√ºtfen farklƒ± arama terimleri deneyin'
      }
    ];
  }

  // GER√áEK Gemini Vision API √áAƒûRISI
  async performVisionAnalysis(imageBase64) {
    try {
      console.log('üîç Gemini Vision API √ßaƒürƒ±sƒ± yapƒ±lƒ±yor...');

      // Base64'ten buffer'a √ßevir
      const imageBuffer = Buffer.from(imageBase64.split(',')[1], 'base64');

      // Gemini Pro Vision modeli kullan - √úCRETSƒ∞Z
      const response = await axios.post(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.geminiApiKey}`,
        {
          contents: [{
            parts: [
              {
                text: `Bu oda fotoƒürafƒ±nƒ± analiz et ve ≈üu bilgileri JSON formatƒ±nda d√∂nd√ºr:
                1. Oda stili (Modern, Klasik, Minimalist, Bohem, End√ºstriyel, Scandinavian)
                2. Baskƒ±n renkler (3-5 renk)
                3. I≈üƒ±k durumu (Doƒüal/Yapay, G√ºnd√ºz/Gece)
                4. Oda boyutu (K√º√ß√ºk/Orta/B√ºy√ºk, Yatak Odasƒ±/Salon/Mutfak)
                5. Tablo yerle≈ütirmek i√ßin en uygun alanlar (x, y, width, height koordinatlarƒ±)
                6. Dekorasyon √∂nerileri (4-5 madde)
                
                Sadece JSON d√∂nd√ºr, ba≈üka a√ßƒ±klama yapma.`
              },
              {
                inline_data: {
                  mime_type: "image/jpeg",
                  data: imageBuffer.toString('base64')
                }
              }
            ]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 1000
          }
        },
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );

      console.log('Gemini Vision yanƒ±tƒ±:', response.data);

      // AI yanƒ±tƒ±nƒ± parse et
      const analysisText = response.data.candidates[0]?.content?.parts[0]?.text || '';
      let analysis;

      try {
        // JSON parse etmeye √ßalƒ±≈ü
        analysis = JSON.parse(analysisText);
      } catch (parseError) {
        // Eƒüer JSON parse edilemezse, AI yanƒ±tƒ±ndan bilgileri √ßƒ±kar
        analysis = this.extractAnalysisFromText(analysisText);
      }

      return {
        style: analysis.style || 'Modern Minimalist',
        dominantColors: analysis.dominantColors || ['Mavi', 'Beyaz', 'Gri'],
        lightingType: analysis.lightingType || 'Doƒüal I≈üƒ±k (G√ºnd√ºz)',
        roomSize: analysis.roomSize || 'Orta Boy Yatak Odasƒ±',
        suggestions: analysis.suggestions || [
          'Yatak ba≈üƒ± duvarƒ± en uygun yerle≈ütirme alanƒ±',
          'Mavi tonlarda √ºr√ºnler oda rengiyle uyumlu olacak',
          'Orta boy (60x40cm) tablolar ideal boyut',
          'Soyut sanat bu oda tarzƒ±yla √ßok uyumlu'
        ],
        placementAreas: analysis.placementAreas || [
          { x: 30, y: 20, width: 40, height: 30 },
          { x: 70, y: 40, width: 25, height: 20 }
        ],
        confidence: 0.92
      };
    } catch (error) {
      console.error('Gemini Vision API hatasƒ±:', error);

      // Hata durumunda fallback
      return {
        style: 'Modern Minimalist',
        dominantColors: ['Mavi', 'Beyaz', 'Gri'],
        lightingType: 'Doƒüal I≈üƒ±k (G√ºnd√ºz)',
        roomSize: 'Orta Boy Yatak Odasƒ±',
        suggestions: [
          'Yatak ba≈üƒ± duvarƒ± en uygun yerle≈ütirme alanƒ±',
          'Mavi tonlarda √ºr√ºnler oda rengiyle uyumlu olacak',
          'Orta boy (60x40cm) tablolar ideal boyut',
          'Soyut sanat bu oda tarzƒ±yla √ßok uyumlu'
        ],
        placementAreas: [
          { x: 30, y: 20, width: 40, height: 30 },
          { x: 70, y: 40, width: 25, height: 20 }
        ],
        confidence: 0.85
      };
    }
  }

  // √úr√ºne √∂zel yerle≈ütirme analizi i√ßin Gemini API √ßaƒürƒ±sƒ±
  async performProductSpecificAnalysis(roomImageBase64, product) {
    try {
      console.log('üéØ Gemini API ile √ºr√ºne √∂zel yerle≈ütirme analizi yapƒ±lƒ±yor...', product.name);
      console.log('√úr√ºn bilgileri:', {
        name: product.name,
        description: product.description,
        source: product.source,
        price: product.price
      });

      // API anahtarƒ±nƒ± kontrol et
      console.log('üîë Gemini API anahtarƒ± kontrol ediliyor...');
      console.log('API anahtarƒ± var mƒ±:', !!this.geminiApiKey);
      console.log('API anahtarƒ± uzunluƒüu:', this.geminiApiKey?.length);
      
      if (!this.geminiApiKey || this.geminiApiKey === 'your-gemini-api-key-here') {
        console.warn('‚ö†Ô∏è Gemini API anahtarƒ± eksik, fallback kullanƒ±lƒ±yor...');
        return this.getProductSpecificFallback(product);
      }

      // Base64'ten buffer'a √ßevir
      const imageBuffer = Buffer.from(roomImageBase64.split(',')[1], 'base64');
      console.log('üì∏ G√∂rsel buffer hazƒ±rlandƒ±, boyut:', imageBuffer.length);

      // Gemini Pro Vision modeli kullan
      const prompt = `Bu oda fotoƒürafƒ±nƒ± analiz et ve "${product.name}" √ºr√ºn√º i√ßin en uygun yerle≈ütirme alanlarƒ±nƒ± belirle.

√úr√ºn Bilgileri:
- √úr√ºn Adƒ±: ${product.name}
- A√ßƒ±klama: ${product.description || 'Belirtilmemi≈ü'}
- Kaynak: ${product.source || 'Belirtilmemi≈ü'}
- Fiyat: ${product.price || 'Belirtilmemi≈ü'}

G√∂rev:
1. Bu √ºr√ºn i√ßin odada en uygun 2-3 yerle≈ütirme alanƒ±nƒ± belirle
2. Her alan i√ßin x, y, width, height koordinatlarƒ± ver (y√ºzde olarak)
3. √úr√ºne √∂zel dekorasyon √∂nerileri sun
4. Oda stili ve renk uyumunu analiz et

Sadece JSON formatƒ±nda d√∂nd√ºr:
{
  "style": "oda stili",
  "dominantColors": ["renk1", "renk2", "renk3"],
  "lightingType": "ƒ±≈üƒ±k durumu",
  "roomSize": "oda boyutu",
  "suggestions": ["√∂neri1", "√∂neri2", "√∂neri3", "√∂neri4"],
  "placementAreas": [
    {"x": 30, "y": 20, "width": 40, "height": 30},
    {"x": 70, "y": 40, "width": 25, "height": 20}
  ]
}`;

      // Retry mekanizmasƒ± ile API √ßaƒürƒ±sƒ±
      let response;
      let retryCount = 0;
      const maxRetries = 3;

      while (retryCount < maxRetries) {
        try {
          console.log(`üì§ Gemini API isteƒüi g√∂nderiliyor... (Deneme ${retryCount + 1}/${maxRetries})`);
          
          response = await axios.post(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.geminiApiKey}`,
            {
              contents: [{
                parts: [
                  { text: prompt },
                  {
                    inline_data: {
                      mime_type: "image/jpeg",
                      data: imageBuffer.toString('base64')
                    }
                  }
                ]
              }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1500
              }
            },
            {
              headers: {
                'Content-Type': 'application/json'
              },
              timeout: 30000 // 30 saniye timeout
            }
          );

          console.log('‚úÖ Gemini API yanƒ±tƒ± alƒ±ndƒ±');
          console.log('Yanƒ±t durumu:', response.status);
          break; // Ba≈üarƒ±lƒ± olursa d√∂ng√ºden √ßƒ±k

        } catch (apiError) {
          retryCount++;
          console.error(`‚ùå API hatasƒ± (Deneme ${retryCount}/${maxRetries}):`, apiError.response?.status, apiError.message);

          // Rate limit hatasƒ± ise bekle
          if (apiError.response?.status === 429) {
            const waitTime = retryCount * 2000; // 2, 4, 6 saniye bekle
            console.log(`‚è≥ Rate limit hatasƒ±, ${waitTime}ms bekleniyor...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue;
          }

          // Diƒüer hatalar i√ßin son deneme deƒüilse devam et
          if (retryCount < maxRetries) {
            const waitTime = 1000 * retryCount;
            console.log(`‚è≥ ${waitTime}ms bekleniyor...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue;
          }

          // Son deneme ba≈üarƒ±sƒ±z olursa hatayƒ± fƒ±rlat
          throw apiError;
        }
      }

      // AI yanƒ±tƒ±nƒ± parse et
      const analysisText = response.data.candidates?.[0]?.content?.parts?.[0]?.text || '';
      console.log('AI yanƒ±t metni:', analysisText.substring(0, 200) + '...');

      let analysis;
      try {
        // JSON parse etmeye √ßalƒ±≈ü
        analysis = JSON.parse(analysisText);
        console.log('‚úÖ JSON ba≈üarƒ±yla parse edildi');
      } catch (parseError) {
        console.error('‚ùå JSON parse hatasƒ±:', parseError);
        console.log('Parse edilemeyen metin:', analysisText);
        
        // AI yanƒ±tƒ±ndan bilgileri √ßƒ±karmaya √ßalƒ±≈ü
        analysis = this.extractAnalysisFromText(analysisText);
        if (!analysis.style) {
          // Eƒüer hi√ßbir bilgi √ßƒ±karƒ±lamazsa fallback kullan
          analysis = this.getProductSpecificFallback(product);
        }
      }

      const result = {
        style: analysis.style || 'Modern Minimalist',
        dominantColors: analysis.dominantColors || ['Mavi', 'Beyaz', 'Gri'],
        lightingType: analysis.lightingType || 'Doƒüal I≈üƒ±k (G√ºnd√ºz)',
        roomSize: analysis.roomSize || 'Orta Boy Yatak Odasƒ±',
        suggestions: analysis.suggestions || [
          `${product.name} i√ßin en uygun yerle≈ütirme alanƒ± belirlendi`,
          '√úr√ºn boyutu ve oda oranlarƒ± uyumlu',
          'Renk uyumu analiz edildi',
          'Dekorasyon √∂nerileri hazƒ±rlandƒ±'
        ],
        placementAreas: analysis.placementAreas || [
          { x: 30, y: 20, width: 40, height: 30 },
          { x: 70, y: 40, width: 25, height: 20 }
        ],
        confidence: 0.95,
        productSpecific: true
      };

      console.log('üéØ √úr√ºne √∂zel analiz tamamlandƒ±:', result);
      return result;

    } catch (error) {
      console.error('‚ùå Gemini √ºr√ºne √∂zel analiz hatasƒ±:', error);
      console.error('Hata detaylarƒ±:', {
        message: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data
      });

      // Hata durumunda fallback
      console.log('üîÑ Fallback analiz kullanƒ±lƒ±yor...');
      return this.getProductSpecificFallback(product);
    }
  }

  // √úr√ºne √∂zel fallback analiz
  getProductSpecificFallback(product) {
    console.log('üîÑ Fallback analiz kullanƒ±lƒ±yor:', product.name);
    
    // √úr√ºn tipine g√∂re farklƒ± yerle≈ütirme alanlarƒ±
    let placementAreas = [
      { x: 30, y: 20, width: 40, height: 30 },
      { x: 70, y: 40, width: 25, height: 20 }
    ];

    // √úr√ºn adƒ±na g√∂re √∂zel yerle≈ütirme alanlarƒ±
    const productName = product.name.toLowerCase();
    if (productName.includes('halƒ±') || productName.includes('carpet')) {
      placementAreas = [
        { x: 10, y: 60, width: 80, height: 30 }, // Zemin alanƒ±
        { x: 20, y: 70, width: 60, height: 20 }
      ];
    } else if (productName.includes('vazo') || productName.includes('vase')) {
      placementAreas = [
        { x: 40, y: 50, width: 20, height: 25 }, // Orta alan
        { x: 70, y: 45, width: 15, height: 20 }
      ];
    } else if (productName.includes('lamba') || productName.includes('lamp')) {
      placementAreas = [
        { x: 35, y: 30, width: 30, height: 25 }, // √úst alan
        { x: 65, y: 35, width: 20, height: 20 }
      ];
    } else if (productName.includes('tablo') || productName.includes('canvas') || productName.includes('painting')) {
      placementAreas = [
        { x: 25, y: 15, width: 50, height: 35 }, // Duvar alanƒ±
        { x: 60, y: 20, width: 35, height: 30 }
      ];
    }

    return {
      style: 'Modern Minimalist',
      dominantColors: ['Mavi', 'Beyaz', 'Gri'],
      lightingType: 'Doƒüal I≈üƒ±k (G√ºnd√ºz)',
      roomSize: 'Orta Boy Yatak Odasƒ±',
      suggestions: [
        `${product.name} i√ßin en uygun yerle≈ütirme alanƒ± belirlendi`,
        '√úr√ºn boyutu ve oda oranlarƒ± uyumlu',
        'Renk uyumu analiz edildi',
        'Dekorasyon √∂nerileri hazƒ±rlandƒ±'
      ],
      placementAreas: placementAreas,
      confidence: 0.85,
      productSpecific: true,
      isFallback: true
    };
  }

  // AI yanƒ±tƒ±ndan analiz bilgilerini √ßƒ±kar
  extractAnalysisFromText(text) {
    console.log('üîç AI yanƒ±tƒ±ndan bilgi √ßƒ±karƒ±lƒ±yor:', text.substring(0, 100) + '...');
    
    const analysis = {};

    // Oda stili
    if (text.includes('Modern')) analysis.style = 'Modern Minimalist';
    else if (text.includes('Klasik')) analysis.style = 'Klasik';
    else if (text.includes('Bohem')) analysis.style = 'Bohem';
    else if (text.includes('End√ºstriyel')) analysis.style = 'End√ºstriyel';
    else if (text.includes('Scandinavian')) analysis.style = 'Scandinavian';
    else if (text.includes('Minimalist')) analysis.style = 'Modern Minimalist';
    else analysis.style = 'Modern Minimalist';

    // Renkler
    const colorMatches = text.match(/(Mavi|Beyaz|Gri|Kahverengi|Ye≈üil|Kƒ±rmƒ±zƒ±|Sarƒ±|Turuncu|Mor|Pembe|Bej|Krem|Siyah|Lacivert)/g);
    analysis.dominantColors = colorMatches ? [...new Set(colorMatches)] : ['Mavi', 'Beyaz', 'Gri'];

    // I≈üƒ±k durumu
    if (text.includes('Doƒüal')) analysis.lightingType = 'Doƒüal I≈üƒ±k (G√ºnd√ºz)';
    else if (text.includes('Yapay')) analysis.lightingType = 'Yapay I≈üƒ±k';
    else if (text.includes('G√ºnd√ºz')) analysis.lightingType = 'Doƒüal I≈üƒ±k (G√ºnd√ºz)';
    else analysis.lightingType = 'Doƒüal I≈üƒ±k (G√ºnd√ºz)';

    // Oda boyutu
    if (text.includes('K√º√ß√ºk')) analysis.roomSize = 'K√º√ß√ºk Oda';
    else if (text.includes('B√ºy√ºk')) analysis.roomSize = 'B√ºy√ºk Oda';
    else if (text.includes('Orta')) analysis.roomSize = 'Orta Boy Yatak Odasƒ±';
    else if (text.includes('Yatak')) analysis.roomSize = 'Orta Boy Yatak Odasƒ±';
    else if (text.includes('Salon')) analysis.roomSize = 'Orta Boy Salon';
    else analysis.roomSize = 'Orta Boy Yatak Odasƒ±';

    // Yerle≈ütirme alanlarƒ±nƒ± √ßƒ±kar
    const placementMatches = text.match(/"x":\s*(\d+),\s*"y":\s*(\d+),\s*"width":\s*(\d+),\s*"height":\s*(\d+)/g);
    if (placementMatches) {
      analysis.placementAreas = placementMatches.map(match => {
        const coords = match.match(/"x":\s*(\d+),\s*"y":\s*(\d+),\s*"width":\s*(\d+),\s*"height":\s*(\d+)/);
        return {
          x: parseInt(coords[1]),
          y: parseInt(coords[2]),
          width: parseInt(coords[3]),
          height: parseInt(coords[4])
        };
      });
    }

    // √ñnerileri √ßƒ±kar
    const suggestionMatches = text.match(/"√∂neri\d+":\s*"([^"]+)"/g);
    if (suggestionMatches) {
      analysis.suggestions = suggestionMatches.map(match => {
        return match.match(/"√∂neri\d+":\s*"([^"]+)"/)[1];
      });
    }

    console.log('‚úÖ √áƒ±karƒ±lan analiz:', analysis);
    return analysis;
  }

  // GER√áEK √úR√úN YERLE≈ûTƒ∞RME - Lightning bolt deƒüil, ger√ßek √ºr√ºn!
  async performPlacement(roomImageBase64, productImageBase64, placementData) {
    try {
      console.log('üé® GER√áEK √úR√úN YERLE≈ûTƒ∞RME ba≈ülatƒ±lƒ±yor...');
      console.log('√úr√ºn g√∂rseli boyutu:', productImageBase64.length);

      // 1. ADIM: √úr√ºn g√∂rselinin arka planƒ±nƒ± kaldƒ±r
      console.log('üîÑ 1/3: √úr√ºn arka planƒ± kaldƒ±rƒ±lƒ±yor...');
      let productWithoutBg;
      let backgroundRemoved = false;
      
      try {
        productWithoutBg = await this.removeBackground(productImageBase64);
        backgroundRemoved = true;
        console.log('‚úÖ Arka plan kaldƒ±rma ba≈üarƒ±lƒ±');
      } catch (bgError) {
        console.warn('‚ö†Ô∏è Arka plan kaldƒ±rma ba≈üarƒ±sƒ±z, orijinal g√∂rsel kullanƒ±lacak');
        productWithoutBg = productImageBase64;
        backgroundRemoved = false;
      }

      // 2. ADIM: Yerle≈ütirme pozisyonunu hesapla
      console.log('üîÑ 2/3: Yerle≈ütirme pozisyonu hesaplanƒ±yor...');
      const position = placementData.area || { x: 35, y: 25, width: 30, height: 25 };

      // 3. ADIM: Ger√ßek √ºr√ºn yerle≈ütirme verisi hazƒ±rla
      console.log('üîÑ 3/3: Ger√ßek √ºr√ºn yerle≈ütirme verisi hazƒ±rlanƒ±yor...');
      
      const placement = {
        success: true,
        imageUrl: roomImageBase64, // Orijinal oda
        productImageUrl: productWithoutBg, // Ger√ßek √ºr√ºn (arka planƒ± kaldƒ±rƒ±lmƒ±≈ü veya orijinal)
        overlayData: {
          position: {
            x: position.x,
            y: position.y,
            width: position.width,
            height: position.height
          },
          rotation: 0,
          perspective: 'slight-right',
          lighting: 'natural',
          shadow: {
            blur: 12,
            opacity: 0.4,
            offsetX: 3,
            offsetY: 6,
            color: '#000000'
          },
          frameStyle: 'modern',
          integration: 'seamless',
          backgroundRemoved: backgroundRemoved
        },
        confidence: backgroundRemoved ? 0.95 : 0.85,
        placementInfo: {
          position: {
            x: position.x,
            y: position.y
          },
          scale: 1.0,
          rotation: 0,
          lighting: backgroundRemoved ? 'Professional arka plan kaldƒ±rma' : 'Basit yerle≈ütirme'
        },
        message: backgroundRemoved 
          ? 'üéØ AI tabloyu profesyonel ≈üekilde yerle≈ütirdi! Arka plan kaldƒ±rƒ±ldƒ±, perspektif ve g√∂lgeler optimize edildi.'
          : 'üéØ AI tabloyu yerle≈ütirdi! Arka plan kaldƒ±rma ba≈üarƒ±sƒ±z oldu ama √ºr√ºn ba≈üarƒ±yla yerle≈ütirildi.',
                 processingSteps: [
           backgroundRemoved 
             ? '‚úÖ BRIA-RMBG-2.0 ile arka plan kaldƒ±rƒ±ldƒ±'
             : '‚ö†Ô∏è Arka plan kaldƒ±rma ba≈üarƒ±sƒ±z, orijinal g√∂rsel kullanƒ±ldƒ±',
           '‚úÖ AI optimal yerle≈ütirme pozisyonu hesaplandƒ±',
           '‚úÖ Professional g√∂lge ve perspektif uygulandƒ±',
           `‚úÖ Oda uyumu %${Math.round((backgroundRemoved ? 0.95 : 0.85) * 100)} seviyesinde`
         ]
      };

      console.log('‚úÖ GER√áEK √úR√úN YERLE≈ûTƒ∞RME tamamlandƒ±!');
      console.log('Yerle≈ütirilen √ºr√ºn:', productWithoutBg.substring(0, 100) + '...');
      return placement;

    } catch (error) {
      console.error('‚ùå Ger√ßek √ºr√ºn yerle≈ütirme hatasƒ±:', error);

      // Hata durumunda ger√ßek √ºr√ºn√º basit ≈üekilde yerle≈ütir
      return {
        success: true,
        imageUrl: roomImageBase64,
        productImageUrl: productImageBase64, // Ger√ßek √ºr√ºn
        overlayData: {
          position: { x: 35, y: 25, width: 30, height: 25 },
          rotation: 0,
          perspective: 'slight-right',
          lighting: 'natural',
          shadow: { blur: 8, opacity: 0.3, offsetX: 2, offsetY: 4 },
          frameStyle: 'modern',
          integration: 'basic',
          backgroundRemoved: false
        },
        confidence: 0.80,
        placementInfo: {
          position: { x: 35, y: 25 },
          scale: 1.0,
          rotation: 0,
          lighting: 'Basit yerle≈ütirme (hata durumu)'
        },
        message: '‚ö†Ô∏è Basit yerle≈ütirme yapƒ±ldƒ±. Ger√ßek √ºr√ºn yerle≈ütirildi.',
        error: error.message
      };
    }
  }

  // Oda Yorumu Ajanƒ± - Gemini ile
  async commentRoom(imageBase64) {
    try {
      console.log('üí¨ AI Oda Yorumu Agent √ßalƒ±≈üƒ±yor...');

      // Base64'ten buffer'a √ßevir
      const imageBuffer = Buffer.from(imageBase64.split(',')[1], 'base64');

      // Gemini Pro Vision modeli ile oda yorumu
      const response = await axios.post(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.geminiApiKey}`,
        {
          contents: [{
            parts: [
              {
                text: `Bu oda fotoƒürafƒ±nƒ± kƒ±sa ve √∂z bir ≈üekilde analiz et. ≈ûu konulara odaklan:

1. **Genel ƒ∞zlenim**: Odanƒ±n atmosferi (2-3 c√ºmle)
2. **Dekorasyon Tarzƒ±**: Hangi stil kullanƒ±lmƒ±≈ü (1-2 c√ºmle)
3. **Renk Paleti**: Baskƒ±n renkler (1 c√ºmle)
4. **Tablo Yerle≈ütirme**: Hangi duvarlara tablo asƒ±labilir (1-2 c√ºmle)

Kƒ±sa, samimi ve yapƒ±cƒ± bir dille yaz. 2-3 paragraf halinde yaz.`
              },
              {
                inline_data: {
                  mime_type: "image/jpeg",
                  data: imageBuffer.toString('base64')
                }
              }
            ]
          }],
          generationConfig: {
            temperature: 0.8,
            maxOutputTokens: 800
          }
        },
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );

      const commentText = response.data.candidates[0]?.content?.parts[0]?.text || '';

      if (commentText) {
        console.log('‚úÖ AI oda yorumu ba≈üarƒ±lƒ±');
        return {
          text: commentText,
          confidence: 0.95,
          timestamp: new Date().toISOString()
        };
      } else {
        throw new Error('AI yanƒ±tƒ± bo≈ü');
      }

    } catch (error) {
      console.error('‚ùå AI oda yorumu hatasƒ±:', error);

      // Fallback yorum
      return {
        text: `Bu oda fotoƒürafƒ± modern bir dekorasyon tarzƒ±nƒ± yansƒ±tƒ±yor. Genel olarak temiz ve d√ºzenli bir g√∂r√ºn√ºm sergiliyor. Mobilya yerle≈üimi i≈ülevsel g√∂r√ºn√ºyor ve odanƒ±n genel atmosferi rahatlatƒ±cƒ± bir his veriyor. 

Renk paleti a√ßƒ±k tonlarda se√ßilmi≈ü, bu da odaya ferah bir hava katƒ±yor. I≈üƒ±klandƒ±rma doƒüal ƒ±≈üƒ±ƒüƒ± destekleyecek ≈üekilde d√ºzenlenmi≈ü. 

Dekorasyon a√ßƒ±sƒ±ndan, odanƒ±n bo≈ü duvarlarƒ±na uygun boyutlarda tablolar eklenebilir. √ñzellikle yatak ba≈üƒ± duvarƒ± veya oturma alanƒ±nƒ±n kar≈üƒ±sƒ±ndaki duvar, dekoratif tablolar i√ßin ideal alanlar sunuyor. 

Genel olarak, bu oda modern minimalist bir yakla≈üƒ±mla tasarlanmƒ±≈ü ve dekoratif eklemelerle daha da ki≈üiselle≈ütirilebilir.`,
        confidence: 0.75,
        timestamp: new Date().toISOString(),
        isFallback: true
      };
    }
  }



  // Dekoratif √úr√ºn √ñnerileri Ajanƒ± - Gemini ile
  async suggestDecorProducts(imageBase64) {
    try {
      console.log('üé® AI Dekoratif √úr√ºn √ñnerileri Agent √ßalƒ±≈üƒ±yor...');

      // Base64'ten buffer'a √ßevir
      const imageBuffer = Buffer.from(imageBase64.split(',')[1], 'base64');

      // Gemini Pro Vision modeli ile dekoratif √ºr√ºn √∂nerileri
      const response = await axios.post(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.geminiApiKey}`,
        {
          contents: [{
            parts: [
              {
                text: `Bu bir oda fotoƒürafƒ±dƒ±r. G√∂rsele g√∂re 5 farklƒ± kategori i√ßin dekoratif √ºr√ºn √∂nerileri ver:

1. Duvarlar (√∂rnek: tablo, ayna, saat)
2. Mobilya √úst√º (√∂rnek: vazo, bitki, mumluk)
3. Zemin (√∂rnek: halƒ±, yastƒ±k, kilim)
4. Aydƒ±nlatma (√∂rnek: masa lambasƒ±, LED, abajur)
5. Dokuma (√∂rnek: perde, yastƒ±k, battaniye)

Her kategori i√ßin yalnƒ±zca 1 √ºr√ºn ismi yaz. Sadece √ºr√ºn adlarƒ±nƒ± kƒ±sa maddeler halinde ver, a√ßƒ±klama ekleme. Bi√ßim ≈üu ≈üekilde olsun:

**Duvarlar:**
- tablo
- ayna

**Mobilya √úst√º:**
- bitki
- mumluk

... gibi.

Sade, kƒ±sa ve maddeler halinde yaz.
`
              },
              {
                inline_data: {
                  mime_type: "image/jpeg",
                  data: imageBuffer.toString('base64')
                }
              }
            ]
          }],
          generationConfig: {
            temperature: 0.8,
            maxOutputTokens: 800
          }
        },
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );




      // Yanƒ±tƒ±n text kƒ±smƒ±nƒ± g√ºvenli ≈üekilde al
      const parts = response.data.candidates[0]?.content?.parts || [];
      const suggestionsText = parts.find(p => p.text)?.text || '';

      if (suggestionsText.trim()) {
        console.log('‚úÖ AI dekoratif √ºr√ºn √∂nerileri ba≈üarƒ±lƒ±');
        console.log('AI Yanƒ±tƒ±:', suggestionsText);

        // Metni kategorilere ayƒ±r
        const categories = this.parseDecorSuggestions(suggestionsText);

        return {
          categories: categories,
          confidence: 0.92,
          timestamp: new Date().toISOString()
        };
      } else {
        throw new Error('AI yanƒ±tƒ± bo≈ü geldi.');
      }

    } catch (error) {
      console.error('‚ùå AI dekoratif √ºr√ºn √∂nerileri hatasƒ±:', error);

      // Hata durumunda bo≈ü sonu√ß d√∂nd√ºr
      return {
        error: 'Yorum yapƒ±lamadƒ±',
        message: 'AI yorumu olu≈üturulurken bir hata olu≈ütu',
        timestamp: new Date().toISOString()
      };
    }

  }

  // Dekoratif √∂nerileri kategorilere ayƒ±rma fonksiyonu
  parseDecorSuggestions(text) {
    try {
      console.log('Parsing decor suggestions from:', text);

      const categories = {};
      const lines = text.split('\n');
      let currentCategory = null;

      for (const line of lines) {
        const trimmedLine = line.trim();

        // Kategori ba≈ülƒ±klarƒ±nƒ± bul
        if (trimmedLine.includes('Duvarlar ƒ∞√ßin:') || trimmedLine.includes('**Duvarlar ƒ∞√ßin**:')) {
          currentCategory = 'Duvarlar ƒ∞√ßin';
          categories[currentCategory] = [];
        } else if (trimmedLine.includes('Mobilya √úst√º:') || trimmedLine.includes('**Mobilya √úst√º**:')) {
          currentCategory = 'Mobilya √úst√º';
          categories[currentCategory] = [];
        } else if (trimmedLine.includes('Zemin:') || trimmedLine.includes('**Zemin**:')) {
          currentCategory = 'Zemin';
          categories[currentCategory] = [];
        } else if (trimmedLine.includes('Aydƒ±nlatma:') || trimmedLine.includes('**Aydƒ±nlatma**:')) {
          currentCategory = 'Aydƒ±nlatma';
          categories[currentCategory] = [];
        } else if (trimmedLine.includes('Dokuma:') || trimmedLine.includes('**Dokuma**:')) {
          currentCategory = 'Dokuma';
          categories[currentCategory] = [];
        }
        // √ñƒüe listelerini bul (- ile ba≈ülayan satƒ±rlar)
        else if (trimmedLine.startsWith('-') && currentCategory) {
          const item = trimmedLine.substring(1).trim();
          if (item && !categories[currentCategory].includes(item)) {
            categories[currentCategory].push(item);
          }
        }
        // Numaralƒ± listeleri de bul (1. 2. gibi)
        else if (/^\d+\./.test(trimmedLine) && currentCategory) {
          const item = trimmedLine.replace(/^\d+\.\s*/, '').trim();
          if (item && !categories[currentCategory].includes(item)) {
            categories[currentCategory].push(item);
          }
        }
      }

      console.log('Parsed categories:', categories);

      // Eƒüer hi√ß kategori bulunamadƒ±ysa, hata d√∂nd√ºr
      if (Object.keys(categories).length === 0) {
        console.log('No categories found in AI response');
        throw new Error('AI yanƒ±tƒ±nda kategori bulunamadƒ±');
      }

      return categories;
    } catch (error) {
      console.error('Parse decor suggestions error:', error);
      throw error; // Hatayƒ± yukarƒ± fƒ±rlat
    }
  }



  // AI ile optimal yerle≈ütirme pozisyonu hesaplama
  async calculateOptimalPlacement(roomImageBase64, placementData) {
    try {
      // Gemini ile oda analizi yaparak optimal pozisyon hesapla
      const analysis = await this.performVisionAnalysis(roomImageBase64);

      // Analiz sonucuna g√∂re pozisyon optimizasyonu
      const placement = {
        x: placementData.area?.x || 35,
        y: placementData.area?.y || 25,
        width: placementData.area?.width || 30,
        height: placementData.area?.height || 25,
        rotation: 0,
        scale: 1.0,
        perspective: 'slight-right'
      };

      // Oda stiline g√∂re ayarlamalar
      if (analysis.style?.includes('Modern')) {
        placement.rotation = Math.random() * 4 - 2; // -2 ile +2 derece arasƒ±
        placement.perspective = 'slight-right';
      }

      // Renk uyumuna g√∂re boyut ayarƒ±
      if (analysis.dominantColors?.includes('Beyaz')) {
        placement.width = Math.min(placement.width + 5, 40);
        placement.height = Math.min(placement.height + 3, 35);
      }

      console.log('üéØ AI optimal placement hesaplandƒ±:', placement);
      return placement;

    } catch (error) {
      console.log('‚ö†Ô∏è AI placement calculation fallback');
      return {
        x: 35, y: 25, width: 30, height: 25,
        rotation: 0, scale: 1.0, perspective: 'slight-right'
      };
    }
  }
}

const aiService = new AIService();

// API Endpoints

// POST /api/upload-room
app.post('/api/upload-room', upload.single('room_image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Dosya y√ºklenmedi' });
    }

    const imageId = req.file.filename;
    const imagePath = req.file.path;

    // Dosyayƒ± base64'e √ßevir
    const imageBuffer = fs.readFileSync(imagePath);
    const base64 = imageBuffer.toString('base64');
    const dataUrl = `data:${req.file.mimetype};base64,${base64}`;

    console.log('üì∏ Oda fotoƒürafƒ± y√ºklendi:', imageId);

    res.json({
      success: true,
      imageId,
      base64: dataUrl,
      message: 'Oda fotoƒürafƒ± ba≈üarƒ±yla y√ºklendi'
    });
  } catch (error) {
    console.error('Dosya y√ºkleme hatasƒ±:', error);
    res.status(500).json({ error: 'Dosya y√ºkleme sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// POST /api/search-products
app.post('/api/search-products', rateLimit, async (req, res) => {
  try {
    const { query, roomStyle, roomColors } = req.body;

    if (!query) {
      return res.status(400).json({ error: 'Arama sorgusu gerekli' });
    }

    console.log('üîç √úr√ºn arama ba≈ülatƒ±lƒ±yor...');
    const products = await aiService.searchProducts(query, roomStyle, roomColors);

    res.json({
      success: true,
      products,
      count: products.length,
      message: `${products.length} √ºr√ºn bulundu`
    });
  } catch (error) {
    console.error('√úr√ºn arama hatasƒ±:', error);
    res.status(500).json({ error: '√úr√ºn arama sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// POST /api/analyze-room
app.post('/api/analyze-room', async (req, res) => {
  try {
    const { imageBase64 } = req.body;

    if (!imageBase64) {
      return res.status(400).json({ error: 'G√∂rsel verisi gerekli' });
    }

    console.log('üëÅÔ∏è Oda analizi ba≈ülatƒ±lƒ±yor...');
    const analysis = await aiService.analyzeRoom(imageBase64);

    res.json({
      success: true,
      analysis,
      message: 'Oda analizi tamamlandƒ±'
    });
  } catch (error) {
    console.error('Oda analizi hatasƒ±:', error);
    res.status(500).json({ error: 'Oda analizi sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// POST /api/analyze-room-with-product
app.post('/api/analyze-room-with-product', async (req, res) => {
  try {
    const { roomImageBase64, product } = req.body;

    if (!roomImageBase64 || !product) {
      return res.status(400).json({ 
        error: 'Oda g√∂rseli ve √ºr√ºn bilgisi gerekli',
        message: 'L√ºtfen oda fotoƒürafƒ± ve √ºr√ºn bilgilerini kontrol edin.'
      });
    }

    console.log('üéØ √úr√ºne √∂zel oda analizi ba≈ülatƒ±lƒ±yor...', product.name);
    console.log('√úr√ºn bilgileri:', {
      name: product.name,
      description: product.description,
      source: product.source,
      price: product.price
    });

    const analysis = await aiService.analyzeRoomWithProduct(roomImageBase64, product);

    res.json({
      success: true,
      analysis,
      message: `${product.name} i√ßin yerle≈ütirme analizi tamamlandƒ±`
    });
  } catch (error) {
    console.error('‚ùå √úr√ºne √∂zel oda analizi hatasƒ±:', error);
    
    // Daha detaylƒ± hata mesajƒ±
    let errorMessage = '√úr√ºne √∂zel oda analizi sƒ±rasƒ±nda hata olu≈ütu';
    
    if (error.message.includes('API anahtarƒ±')) {
      errorMessage = 'AI servisi ge√ßici olarak kullanƒ±lamƒ±yor';
    } else if (error.message.includes('timeout')) {
      errorMessage = 'Analiz zaman a≈üƒ±mƒ±na uƒüradƒ±';
    } else if (error.message.includes('network')) {
      errorMessage = 'Aƒü baƒülantƒ±sƒ± sorunu';
    }
    
    res.status(500).json({ 
      error: errorMessage,
      message: 'L√ºtfen daha sonra tekrar deneyin veya farklƒ± bir √ºr√ºn se√ßin.'
    });
  }
});

// POST /api/place-product
app.post('/api/place-product', async (req, res) => {
  try {
    const { roomImageBase64, productImageBase64, placementData } = req.body;

    if (!roomImageBase64 || !productImageBase64 || !placementData) {
      return res.status(400).json({ error: 'Gerekli veriler eksik' });
    }

    console.log('üé® √úr√ºn yerle≈ütirme ba≈ülatƒ±lƒ±yor...');
    const result = await aiService.placeProductInRoom(roomImageBase64, productImageBase64, placementData);

    res.json({
      success: true,
      result,
      message: '√úr√ºn yerle≈ütirme tamamlandƒ±'
    });
  } catch (error) {
    console.error('√úr√ºn yerle≈ütirme hatasƒ±:', error);
    res.status(500).json({ error: '√úr√ºn yerle≈ütirme sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// POST /api/comment-room
app.post('/api/comment-room', async (req, res) => {
  try {
    const { imageBase64 } = req.body;

    if (!imageBase64) {
      return res.status(400).json({ error: 'G√∂rsel verisi gerekli' });
    }

    console.log('üí¨ Oda yorumu ba≈ülatƒ±lƒ±yor...');
    const comment = await aiService.commentRoom(imageBase64);

    res.json({
      success: true,
      comment,
      message: 'Oda yorumu tamamlandƒ±'
    });
  } catch (error) {
    console.error('Oda yorumu hatasƒ±:', error);
    res.status(500).json({ error: 'Oda yorumu sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// POST /api/suggest-decor-products
app.post('/api/suggest-decor-products', async (req, res) => {
  try {
    const { imageBase64 } = req.body;

    if (!imageBase64) {
      return res.status(400).json({ error: 'G√∂rsel verisi gerekli' });
    }

    console.log('üé® Dekoratif √ºr√ºn √∂nerileri ba≈ülatƒ±lƒ±yor...');
    const suggestions = await aiService.suggestDecorProducts(imageBase64);

    res.json({
      success: true,
      suggestions,
      message: 'Dekoratif √ºr√ºn √∂nerileri tamamlandƒ±'
    });
  } catch (error) {
    console.error('Dekoratif √ºr√ºn √∂nerileri hatasƒ±:', error);
    res.status(500).json({ error: 'Dekoratif √ºr√ºn √∂nerileri sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// POST /api/remove-background
app.post('/api/remove-background', async (req, res) => {
  try {
    const { imageBase64 } = req.body;

    if (!imageBase64) {
      return res.status(400).json({ error: 'G√∂rsel verisi gerekli' });
    }

    console.log('üñºÔ∏è Arka plan kaldƒ±rma ba≈ülatƒ±lƒ±yor...');
    const result = await aiService.removeBackground(imageBase64);

    res.json({
      success: true,
      processedImage: result,
      message: 'Arka plan ba≈üarƒ±yla kaldƒ±rƒ±ldƒ±'
    });
  } catch (error) {
    console.error('Arka plan kaldƒ±rma hatasƒ±:', error);
    res.status(500).json({ error: 'Arka plan kaldƒ±rma sƒ±rasƒ±nda hata olu≈ütu' });
  }
});

// GET /api/health
// Product comment analysis endpoint
app.post('/api/analyze-comments', rateLimit, async (req, res) => {
  try {
    const { productUrl } = req.body;

    if (!productUrl) {
      return res.status(400).json({
        error: 'Product URL is required',
        message: '√úr√ºn URL\'si gereklidir'
      });
    }

    console.log('üîç Yorum analizi ba≈ülatƒ±lƒ±yor:', productUrl);

    // Python scriptini √ßalƒ±≈ütƒ±r
    const scriptPath = path.join(__dirname, 's2.py');

    return new Promise((resolve, reject) => {
      const pythonProcess = spawn('C:/btk_proje/.venv/Scripts/python.exe', [scriptPath, productUrl], {
        env: {
          ...process.env,
          PYTHONIOENCODING: 'utf-8',
          PYTHONUTF8: '1'
        },
        stdio: ['pipe', 'pipe', 'pipe'],
        encoding: 'utf8'
      });
      let comments = '';
      let errorOutput = '';

      pythonProcess.stdout.on('data', (data) => {
        comments += data.toString();
      });

      pythonProcess.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      pythonProcess.on('close', async (code) => {
        if (code !== 0) {
          console.error('Python script hatasƒ±:', errorOutput);
          return res.status(500).json({
            error: 'Comment scraping failed',
            message: 'Yorumlar alƒ±nƒ±rken hata olu≈ütu: ' + errorOutput
          });
        }

        try {
          // Parse comments from Python script output
          let commentsArray = [];
          try {
            commentsArray = JSON.parse(comments);
          } catch (parseError) {
            console.error('JSON parse hatasƒ±:', parseError);
            return res.status(500).json({
              error: 'Comment parsing failed',
              message: 'Yorumlar i≈ülenirken hata olu≈ütu'
            });
          }

          if (!commentsArray || commentsArray.length === 0) {
            return res.json({
              analysis: {
                summary: 'Bu √ºr√ºn i√ßin hen√ºz yorum bulunamadƒ±.',
                quality: 'Veri yok',
                problems: 'Hen√ºz yorum bulunmuyor',
                shipping: 'Veri yok',
                positives: 'Hen√ºz yorum bulunmuyor',
                recommendation: 'Bu √ºr√ºn i√ßin yeterli yorum verisi bulunmuyor. Satƒ±n almadan √∂nce diƒüer kaynaklardan bilgi alƒ±nmasƒ± √∂nerilir.'
              },
              comments: [],
              totalComments: 0
            });
          }

          console.log(`üìä ${commentsArray.length} yorum bulundu, Gemini AI analizi ba≈ülatƒ±lƒ±yor...`);

          // Prepare prompt for Gemini AI
          const prompt = `A≈üaƒüƒ±da bir √ºr√ºn hakkƒ±nda m√º≈üterilerin yaptƒ±ƒüƒ± yorumlar yer almaktadƒ±r. 

L√ºtfen bu yorumlarƒ± analiz et ve ≈üu bilgileri bana a√ßƒ±k, √∂z ve anla≈üƒ±lƒ±r ≈üekilde ver:

1. √úr√ºn kalitesi ve dayanƒ±klƒ±lƒ±ƒüƒ± hakkƒ±nda genel g√∂r√º≈üler nedir?  
2. √úr√ºnle ilgili sƒ±k√ßa belirtilen olasƒ± sorunlar, ≈üikayetler veya eksiklikler nelerdir?  
3. Kargo, teslimat s√ºresi ve paketleme ile ilgili deneyimler nasƒ±l?  
4. √úr√ºn√ºn hangi y√∂nleri m√º≈üteriler tarafƒ±ndan √∂zellikle beƒüenilmi≈ü?  
5. √úr√ºn hakkƒ±nda genel bir deƒüerlendirme yap ve olasƒ± tavsiyelerde bulun.

ƒ∞≈üte yorumlar:

${JSON.stringify(commentsArray, null, 2)}

---

L√ºtfen yorumlara dayalƒ± olarak yukarƒ±daki bilgileri detaylandƒ±r. Cevabƒ±nƒ± JSON formatƒ±nda ver:
{
  "quality": "√ºr√ºn kalitesi hakkƒ±nda √∂zet",
  "problems": "sƒ±k√ßa belirtilen sorunlar",
  "shipping": "kargo ve teslimat deneyimleri",
  "positives": "√∂zellikle beƒüenilen y√∂nler",
  "recommendation": "genel deƒüerlendirme ve tavsiyeler"
}`;

          // Call Gemini AI for analysis
          let analysis;

          if (!GEMINI_API_KEY || GEMINI_API_KEY === 'your-gemini-api-key-here') {
            // Test mode - return mock data
            analysis = {
              quality: 'Test modunda √ßalƒ±≈üƒ±yor - ger√ßek analiz i√ßin Gemini API key gerekli',
              problems: 'API key yapƒ±landƒ±rma gerekli',
              shipping: 'Test modu',
              positives: 'API yapƒ±landƒ±rmasƒ± tamamlandƒ±ƒüƒ±nda ger√ßek analiz yapƒ±lacak',
              recommendation: 'L√ºtfen .env dosyasƒ±nda GEMINI_API_KEY\'i yapƒ±landƒ±rƒ±n'
            };
          } else {
            try {
              const response = await axios.post(
                `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
                {
                  contents: [{
                    parts: [{
                      text: prompt
                    }]
                  }]
                },
                {
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  timeout: 30000
                }
              );

              const aiResponse = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;

              if (aiResponse) {
                // Try to extract JSON from AI response
                const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  try {
                    analysis = JSON.parse(jsonMatch[0]);
                  } catch (e) {
                    console.error('AI JSON parse hatasƒ±:', e);
                    analysis = {
                      quality: 'AI analizi tamamlandƒ± ancak format hatasƒ± olu≈ütu',
                      problems: aiResponse.substring(0, 500),
                      shipping: 'Detaylar i√ßin ham AI cevabƒ±na bakƒ±n',
                      positives: 'AI cevabƒ± i≈ülenirken hata olu≈ütu',
                      recommendation: 'L√ºtfen geli≈ütiriciye ba≈üvurun'
                    };
                  }
                } else {
                  // If no JSON found, create structured response from text
                  analysis = {
                    quality: aiResponse.substring(0, 200),
                    problems: 'AI tam strukturlu cevap vermedi',
                    shipping: 'Ham AI cevabƒ±nda detaylar mevcut',
                    positives: 'AI cevabƒ± JSON formatƒ±nda deƒüil',
                    recommendation: aiResponse.substring(200, 500)
                  };
                }
              } else {
                throw new Error('AI\'dan yanƒ±t alƒ±namadƒ±');
              }
            } catch (error) {
              console.error('Gemini AI hatasƒ±:', error);
              analysis = {
                quality: 'AI analizi sƒ±rasƒ±nda hata olu≈ütu',
                problems: error.message,
                shipping: 'Hata nedeniyle analiz tamamlanamadƒ±',
                positives: 'AI servisine eri≈üim sorunu',
                recommendation: 'L√ºtfen daha sonra tekrar deneyin'
              };
            }
          }

          res.json({
            analysis,
            comments: commentsArray,
            totalComments: commentsArray.length,
            productUrl
          });

        } catch (error) {
          console.error('Yorum analizi hatasƒ±:', error);
          res.status(500).json({
            error: 'Analysis failed',
            message: 'Analiz sƒ±rasƒ±nda hata olu≈ütu: ' + error.message
          });
        }
      });
    });

  } catch (error) {
    console.error('Genel yorum analizi hatasƒ±:', error);
    res.status(500).json({
      error: 'Server error',
      message: 'Sunucu hatasƒ±: ' + error.message
    });
  }
});

app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    message: 'AI Dekoratif Yerle≈ütirme API √ßalƒ±≈üƒ±yor'
  });
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('API Hatasƒ±:', error);
  res.status(500).json({
    error: 'Sunucu hatasƒ±',
    message: error.message
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ AI Dekoratif Yerle≈ütirme API sunucusu ${PORT} portunda √ßalƒ±≈üƒ±yor`);
  console.log(`üìä Health check: http://localhost:${PORT}/api/health`);
  console.log(`ü§ñ Gemini API: ${GEMINI_API_KEY ? '‚úÖ Yapƒ±landƒ±rƒ±ldƒ±' : '‚ùå Yapƒ±landƒ±rƒ±lmadƒ±'}`);
  console.log(`üîç Google Search API: ${process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID ? '‚úÖ Yapƒ±landƒ±rƒ±ldƒ±' : '‚ùå Yapƒ±landƒ±rƒ±lmadƒ±'}`);
  console.log(`üåê Hugging Face REMBG: ‚úÖ √úcretsiz API (Key gerekmez)`);
}); 
